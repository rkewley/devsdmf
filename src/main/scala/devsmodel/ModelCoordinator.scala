/*

Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.

*/

package devsmodel

import java.time.Duration

import akka.actor._
import dmfmessages.DMFSimMessages._
import simutils._
import akka.event.{Logging, LoggingAdapter}
import simutils.{UniqueNames, LoggingActor}

import scala.collection.mutable

/**
  * This object is a faithful representation of the model coordinator as described by as described by Chow
  * and Ziegler in <a href="http://dl.acm.org/citation.cfm?id=194336">Parallel DEVS: a parallel, hierarchical, modular, modeling formalism</a>
  * A PostScript version of the paper is available <a href="http://www.cs.mcgill.ca/~hv/articles/DiscreteEvent/DEVS/rev-devs.ps.gz">here</a>.
  * A ModelCoordinator coordinates the actions of multiple subordinate [[ModelSimulator]]s or other model coordinators.
  * To a parent ModelCoordinator, the behavior of a [[ModelSimulator]] and ModelCoordinator are identical.  This
  * enables hierarchical and modular construction of DEVS simulations.
 *
  * @param initialTime  The initial start time of the simulation, usually 0
  * @param randomActor  The random actor to set random number seeds
  * @param simLogger The logger for the simulation
  */
abstract class ModelCoordinator(val initialTime: Duration, randomActor: ActorRef, val simLogger: ActorRef)
  extends LoggingActor with UniqueNames with MessageConverter {

  override val supervisorStrategy =
    OneForOneStrategy() {
      case e: ActorInitializationException => {
        SupervisorStrategy.Escalate
        }
      }

  /**
   * A map containing all of the subordinate models and the scheduled time of their next internal state transition
   */
  protected val nextMap: mutable.HashMap[ActorRef, Duration] = new mutable.HashMap[ActorRef, Duration]()

  /**
   * Convenience method to get a list of subordinate [[ModelSimulator]]s or [[ModelCoordinator]]s
 *
   * @return A set of subordinate models
   */
  def subordinates() = nextMap.keySet

  /**
   * The current simulation time
   */
  protected var currentTime = initialTime

  /**
   * Bag of external event messages to be executed
   */
  protected var externalEvents: List[ExternalEvent[_ <: java.io.Serializable]] = List()

  /**
   * An index incremented each time a unique event index is generated by a call to [[nextEventIndex]]
   */
  protected var runningEventIndex: Long = 0

  /**
   * Call this method from the [[handleExternalEvent()]] method in order to get a unique index to assign to an [[dmfmessages.DMFSimMessages.EventMessage]]
 *
   * @return A unique event index to be assigned to an event
   */
  def nextEventIndex: Long = {
    runningEventIndex = runningEventIndex + 1
    logDebug("Assigning event index " + (runningEventIndex - 1))
    runningEventIndex - 1
  }

  /**
    * Event messages cannot be send directly to subordinate [[ModelSimulator]]s.  This utility method must be
    * used so that the [[awaitingBagEvents]] and [[influences]] lists are updated properly.
 *
    * @param externalEvent  The event to send
    * @param receiveActor  The subordinate [[ModelCoordinator]] or [[ModelSimulator]] to receive the event
    */
  def sendEventMessage(externalEvent: ExternalEvent[_ <: java.io.Serializable], receiveActor: ActorRef): Unit = {
    val nextIndex = nextEventIndex
    val eventMessage = externalEvent.eventData match {
      case g: com.google.protobuf.Message =>
        val devsEventData = ModelSimulator.buildDEVSEventData(DEVSEventData.EventType.EXTERNAL, externalEvent.executionTime, g)
        ModelSimulator.buildEventMessage(devsEventData, externalEvent.executionTime, nextIndex)
      case s: java.io.Serializable =>
        EventMessageCase(externalEvent, externalEvent.executionTime, nextIndex)
    }

    awaitingBagEvents = AwaitingEventBagging(receiveActor, nextIndex) :: awaitingBagEvents
    influences = receiveActor :: influences
    val t = externalEvent.executionTime
    logDebug(t + "Sending message to " + receiveActor + ": " + eventMessage)
    logDebug(t + "Added message to awaitingBagEvents which now has size " + awaitingBagEvents.size)
    logDebug(t + "Adding " + receiveActor + " to influences")
    receiveActor ! eventMessage
  }

  /**
   * A utility class used by the [[getImminentSet]] method to store the list of imminents and the minimum internal state transition time among them
 *
   * @param imminents  A list of imminent subordinate models
   * @param nextTime  The minimun internal state transition time from the subordinate models
   */
  case class Imminents(imminents:  List[ActorRef], nextTime: Duration)

  /**
   * A utility class used to by the [[awaitingBagEvents]] list to store subordinate models to which an [[EventMessage]] has
   * been sent and a unique index assigned to each external event
 *
   * @param actor  Subordinate model to which [[EventMessage]] has been sent
   * @param eventIndex  A unique index for this coordination
   */
  case class AwaitingEventBagging(actor: ActorRef, eventIndex: Long)

  /**
   * The list of subordinate models scheduled at the same time for the next internal state transition
   */
  protected var imminents: List[ActorRef] = List()

  /**
   * A list of subordinate models to which an [[EventMessage]] has been sent
   */
  protected var influences: List[ActorRef] = List()

  /**
   * A list of subordinate models for which we await completion of generation output
   */
  protected var awaitingOutputDone: List[ActorRef] = List()

  /**
   * A list of subordinate models for which we await completion of bagging an [[EventMessage]]
   */
  protected var awaitingBagEvents: List[AwaitingEventBagging] = List()

  /**
   * A list of subordinate models to which a [[GetNextTime]] message is sent during initialization
   */
  protected var awaitingNextTime: List[ActorRef] = List()

  /**
   * A list of subordiante models to which [[ProcessEventMessages]] has been sent in the [[processingOutput]] phase
   */
  protected var awaitingMessageProcessing: List[ActorRef] = List()

  /**
   * A list of subordinate models to which a [[Terminate]] message has been send during simulation termination
   */
  protected var awaitingTermination: List[ActorRef] = List()

  /**
   * A list of submordinate models to which and [[ExecuteTransition]] message is sent in the [[checkDonePassingMessages]]
   * method before going to the [[processingTransitions]] phase.  This set is composed of a combination of
   * models in the [[imminents]] list and the [[influences]] list.  This set is the set of subordinate models
   * executing simultaneous and parallel state transitions.
   */
  protected var synchronizeSet: List[ActorRef] = List()

  /**
   * Utility function to determine the time of the next scheduled internal state transition from the subordinate models
 *
   * @return  The time of the next scheduled internal state transition
   */
  def getNextTime = nextMap.values.min

  /**
   * Utility function to determine the time of the next scheduled internal state transition from the subordinate models
   * and the list of models scheduled to make a transition at that time
 *
   * @return  [[Imminents]] data structrue containing the list of imminent models and their scheduled transition time
   */
  def getImminentSet: Imminents = {
    val t = getNextTime
    Imminents(nextMap.filter { case(actor, time) =>
      time.compareTo(t) == 0
    }.keySet.toList, t)
  }

  /**
   * This function can be overridden by subclasses in order to perform shutdown, logging, and data collection at the
   * end of the simulation.
   */
  def preTerminate() = {}


  /**
   * Function called after receiving an [[OutputDone]] or [[BagEventDone]] message.  If both the [[awaitingOutputDone]] and
   * [[awaitingBagEvents]] lists are empty, this method will send an [[OutputDone]] message to the parent coordinator
   * and transition this coordinator from the [[processingOutput]] state to the [[passingMessages]] state
 *
   * @param t  The time of the check
   */
  private def checkDoneProcessingOutput(t: Duration): Unit = {
    if(awaitingOutputDone.isEmpty && awaitingBagEvents.isEmpty) {
      context.parent ! ModelSimulator.buildOutputDone(t)
      logDebug(t + " Done processing putput.")
    } else {
      logDebug(t + " awaitingOutputDone still has " + awaitingOutputDone.size + " members.")
      logDebug(t + " awaitingBagEvents still has " + awaitingBagEvents.size + " members.")
    }
  }


  /**
   * If all of the [[BagEventDone]] responses have been received in the [[passingMessages]] state, the [[awaitingBagEvents]]
   * list will be empty, and it is time to execute a state transition for all subordiante models in the synchronize set,
   * which is the union of the [[imminents]] and [[influences]] list without duplicates.  Send an [[ExecuteTransition]]
   * message to each model in the synchronizeSet and transition to the [[processingTransitions]] state.
   */
  private def checkDonePassingMessages(t: Duration): Unit = {

    if (awaitingBagEvents.isEmpty) {
      synchronizeSet = (influences ::: imminents).distinct
      if (synchronizeSet.isEmpty) {
        context.parent ! ModelSimulator.buildStateTransitionDone(t, getNextTime)
        logDebug("Become: Synchronize set is empty, transitioning from passingMessages to processingOutput")
        context.become(processingOutput)
      } else {
        logDebug(t + "sending ExeucteTranisiton to synchronize set: " + synchronizeSet)
        synchronizeSet.foreach(s => s ! ModelSimulator.buildExecuteTransition(currentTime))
        imminents = List()
        influences = List()
        logDebug("Become: awaitingBagEvents is empty.  Transitioning from passingMessages to processingTransitions phase.")
        context.become(processingTransitions)
      }
    }
    else {
      logDebug("awaitingBagEvents still has " + awaitingBagEvents.size + " members.")
    }
  }


  /**
   * This is a very important abstract method that must be overridden by any subclasses of ModelCoordinator.  This function
   * will route output messages from subordinate models to the appropriate destinations, whether they be other subordinate models
   * or to the parent model, transitioning the outputs through a translation function as necessary.  In the words of Ziegler
   * and Chow's paper, output is received from a specific subordinate model, i.  For all j models in the influence set Ii,
   * first send the output through an i to j translation Zij before sending the message to j.
   *
   * If an [[EventMessage]] is sent to a model, send it using the [[sendEventMessage()]] method.
   *
   * Furthermore, if self is also  in the influence set Ii, the message must also be transmitted upward to the parent
   * coordinator after going through an i to self translation Zi,self.
   *
   * @param eventSender  The subordinate model from which the output is recieved
   * @param output  The output message received
   */
  def handleOutputEvent(eventSender: ActorRef, output: OutputEvent[_ <: java.io.Serializable])

  /**
   * This method may be overridden by subclasses of ModelCoordinator to enable more complex routing.  By default, it invokes [[handleOutputEvent]].
   *
   *
   * @param eventSender  The subordinate model from which the output is recieved
   * @param output  The output message received
   */
  def routeOutputEvent(eventSender: ActorRef, output: OutputEvent[_ <: java.io.Serializable]) {
    handleOutputEvent( eventSender, output )
  }

  /**
   * This is another important abastract method that must be overridden by subclasses of ModelCoordinator.  This function
   * will route any external event messages to the appropriate subordinate models.  It will process those events
   * through a translation function as necessary.
   *
   * If an [[EventMessage]] is sent to a model, send it using the [[sendEventMessage()]] method.
   *
   * @param externalEvent  The external event to be handled
   */
  def handleExternalEvent(externalEvent: ExternalEvent[_ <: java.io.Serializable])

  /**
   * This method may be overridden by subclasses of ModelCoordinator to enable more complex routing.  By default, it invokes [[handleExternalEvent]].
   *
   *
   * @param externalEvent  The external event to be routed
   */
  def routeExternalEvent(externalEvent: ExternalEvent[_ <: java.io.Serializable]) {
    handleExternalEvent( externalEvent )
  }

  /**
   * The ModelCoordinator is in this state only during initialization.  Upon receipt of a [[GetNextTime]] message, send a
   * [[GetNextTime]] message to all subordinate models and await a [[NextTime]] result from each.  Upon receipt of a
   * [[NextTime]] message, store the result in the [[nextMap]] and remove the sender from the [[awaitingNextTime]] list.
   * Once all results are received, send a [[NextTime]] message to the parent model with the result of [[getNextTime]].
   * Then transition to the [[processingOutput]] state.
 *
   * @return
   */
  def receive = {
    case gnt: GetNextTime =>
      awaitingNextTime = nextMap.keySet.toList
      nextMap.keySet.foreach(_ ! gnt)
      logDebug("Initializing by getting next time from subordinate models")

    case nt: NextTime =>
      val t: Duration = Duration.parse(nt.getTimeString)
      nextMap.put(sender(), t)
      awaitingNextTime = awaitingNextTime.filterNot(_ == sender())
      logDebug(t + " Received NextTime from " + sender().path.name + ". Awaiting " + awaitingNextTime.size + " more.")
      if (awaitingNextTime.isEmpty) {
        context.parent ! ModelSimulator.buildNextTime(getNextTime)
        logDebug("Become: " + t + " Received all NextTime messages.  Transitioning from receive to processingOutput.")
        context.become(processingOutput)
      }
    case m: Any=>
      throw new SynchronizationException("Received message in recieve state with no handler: [" + m.getClass + "] " + m)
  }


  def generateOutput(g: GenerateOutput): Unit = {
    val t = Duration.parse(g.getTimeString)
    val imminentSet = getImminentSet
    if (t.compareTo(imminentSet.nextTime) == 0) {
      currentTime = t
      imminents = imminentSet.imminents
      awaitingOutputDone = imminents
      logDebug(t + "Getting output from imminent set:")
      imminents.foreach { i =>
        logDebug(i.path.name + " is in imminent set.")
        i ! ModelSimulator.buildGenerateOutput(t)
      }
    }
    else {
      throw new SynchronizationException(t + " in processing output, time in GenerateOutput " + t + " does not match next time: " + getNextTime)
    }
  }


  /**
   * This is the behavior of the ModelCoordinator when it is processing output from subordinate models.
   *
   * Upon receipt of a [[GenerateOutput]] message, initialize the [[awaitingOutputDone]] list with the imminent set
   * and send a [[GenerateOutput]] message to each imminent subordinate model.
   *
   * Upon receipt of an [[OutputDone]] message, remove the sender from the [[awaitingOutputDone]] list and call
   * [[checkDoneProcessingOutput()]] to see if all output processing is done.
   *
   * Upon receipt of an [[OutputMessage]], pass the message and sender to the [[handleOutputEvent()]] method in order
   * to route the message to the appropriate models in the set of models influenced by that sender.
   *
   * Upon receipt of a [[BagEventDone]] message, remove the corresponing entry from the [[awaitingBagEvents]] list and
   * call [[checkDoneProcessingOutput()]] to see if all output processing is done.
   *
   * Upon receipt of an [[EventMessage]], add the message to the [[externalEvents]] list and return a [[BagEventDone]] message
   *
   */
  def processingOutput: Receive = {
    case g: GenerateOutput =>
      generateOutput(g)

    case od: OutputDone =>
      val t: Duration = Duration.parse(od.getTimeString)
      if (t.compareTo(currentTime) == 0) {
        awaitingOutputDone = awaitingOutputDone.filterNot(i => i == sender())
        logDebug(t + " Received output done from " + sender().path.name)
        checkDoneProcessingOutput(t)
      }
      else {
        throw new SynchronizationException(t + " in processing output, time in OutputDone " + t + " does not match current time: " + currentTime)
      }

    case om: OutputMessage =>
      val outputTime = Duration.parse(om.getTimeString)
      if (outputTime.compareTo(currentTime) == 0) {
        val outputData = convertOutput(om.getOutput) match {case s: java.io.Serializable => s}
        logDebug(outputTime + " Handling output event " + outputData + " from " + sender().path.name)
        routeOutputEvent(sender(), OutputEvent(outputTime, outputData))
      }
      else {
        throw new SynchronizationException(outputTime + " in processing output, time in OutputMessage " + outputTime + " does not match current time: " + currentTime)
      }

    case OutputMessageCase(output: java.io.Serializable, t) =>
      if (t.compareTo(currentTime) == 0) {
        logDebug(t + " Handling output event " + output + " from " + sender().path.name)
        routeOutputEvent(sender(), OutputEvent(t, output))
      }
      else {
        throw new SynchronizationException(t + " in processing output, time in OutputMessage " + t + " does not match current time: " + currentTime)
      }

    case bed: BagEventDone =>
      val t = Duration.parse(bed.getTimeString)
      val eventIndex = bed.getEventIndex
      awaitingBagEvents = awaitingBagEvents.filterNot(a => a.actor == sender() && a.eventIndex == eventIndex)
      logDebug(t + "Received BagEventDone with index " + eventIndex + " from " + sender().path.name)
      checkDoneProcessingOutput(t)


    case em: EventMessage =>
      val t: Duration = Duration.parse(em.getTimeString)
      val executionTime: Duration = Duration.parse(em.getEvent.getExecutionTimeString)
      val externalEvent = ExternalEvent(executionTime, convertEvent(em.getEvent.getEventData) match {case s: java.io.Serializable => s})
      externalEvents = externalEvent :: externalEvents
      logDebug(t + " Bagging external event " + externalEvent + " with index " + em.getEventIndex + " from " + sender().path.name)
      sender() ! ModelSimulator.buildBagEventDone(t, em.getEventIndex)

    case EventMessageCase(event, t, eventIndex) =>
      val externalEvent = event
      externalEvents = externalEvent :: externalEvents
      logDebug(t + " Bagging external event " + externalEvent + " with index " + eventIndex + " from " + sender().path.name)
      sender() ! ModelSimulator.buildBagEventDone(t, eventIndex)

    case p: ProcessEventMessages =>
      subordinates().foreach(_ ! p)
      awaitingMessageProcessing = subordinates().toList
      logDebug(p.getTimeString + " Received ProcessEventMessages from " + sender + " Sending to " + awaitingMessageProcessing.size + " subordinates.")
      if(awaitingMessageProcessing.isEmpty) {
        throw new SynchronizationException("Illegal ModelCoordinator with no subordinates.")
      }

    case rpm: ReadyToProcessMessages =>
      val t: Duration = Duration.parse(rpm.getTimeString)
      awaitingMessageProcessing = awaitingMessageProcessing.filterNot(_ == sender)
      logDebug(t + " Received ReadyToProcessMessages from " + sender + ".  awaitingMessageProcessing has " + awaitingMessageProcessing.size + " members.")
      if (awaitingMessageProcessing.isEmpty) {
        context.parent ! rpm
        logDebug(t + "Done processing messages.")
        if (imminents.nonEmpty || externalEvents.nonEmpty) {
          logDebug("Become: Transitioning from processingOutput to passingMessages.")
          context.become(passingMessages)
        } else {
          logDebug("Become: NOT Transitioning from processingOutput")
        }
      }

    case t: Terminate =>
      preTerminate()
      awaitingTermination = subordinates().toList
      subordinates().foreach(_ ! t)

    case td: TerminateDone =>
      logDebug(sender().path.name + " completed termination")
      awaitingTermination = awaitingTermination.filterNot(_ == sender())
      if (awaitingTermination.isEmpty) {
        logDebug("All subordinates completed termination.")
        context.parent ! td
      }

    case et: ExecuteTransition =>
      if( externalEvents.nonEmpty ) {
        logDebug("Become: Transitioning from processingOutput to passingMessages due to external events.")
        context.become(passingMessages)
        self ! et
      } else {
        throw new SynchronizationException("In processingOutput, got ExecuteTransition with no external events.")
      }

    case m: Any=>
      throw new SynchronizationException("Received message from " + sender + " in processingOutput state with no handler: [" + m.getClass + "] " + m)
  }

  /**
   * In this state, the coordinator empties its message bag, translates those messages as required and sends them to
   * subordinate models.
   *
   * Upon receipt of an [[ExecuteTransition]] message, empty the [[externalEvents]] bag and call [[handleExternalEvent()]]
   * for each event.
   *
   * Upon receipt of an [[EventMessage]], add the message to the [[externalEvents]] list and return a [[BagEventDone]] message
   *
   * Upon receipt of a [[BagEventDone]] message, remove the sending actor from the [[awaitingBagEvents]] list and
   * call [[checkDonePassingMessages]]
   */
  def passingMessages: Receive = {
    case et: ExecuteTransition =>
        val t: Duration = Duration.parse(et.getTimeString)
        if (t.compareTo(currentTime) >= 0 && t.compareTo(getNextTime) <= 0) {
          logDebug(t + " Executing external transitions.")
          // reverse takes O(n) time, but events should be delivered in FIFO
          // order (LIFO is surprising to user.  A Queue does not save time
          // as it effectively performs a reverse when elements are
          // removed, which is only performed once)
          externalEvents.reverse.foreach {e =>
            logDebug(t + " Handling external event: " + e)
            routeExternalEvent(e)
          }
          externalEvents = List()
          currentTime = t
          checkDonePassingMessages(t)
        }
        else {
          throw new SynchronizationException(t + " in passing messages, time in ExecuteTransition message " + t +
            " is not between current time: " + currentTime + " and next scheduled transition " + getNextTime)
        }

    case em: EventMessage =>
      val t: Duration = Duration.parse(em.getTimeString)
      val executionTime: Duration = Duration.parse(em.getEvent.getExecutionTimeString)
      val externalEvent = new ExternalEvent(executionTime, convertEvent(em.getEvent.getEventData) match {case s: java.io.Serializable => s})
      externalEvents = externalEvent :: externalEvents
      logDebug(t + " Bagging external event " + externalEvent + " with index " + em.getEventIndex + " from " + sender().path.name)
      sender() ! ModelSimulator.buildBagEventDone(t, em.getEventIndex)

    case EventMessageCase(event, t, eventIndex) =>
      //val externalEvent = ExternalEvent(t, event)
      val externalEvent = event
      externalEvents = externalEvent :: externalEvents
      logDebug(t + " Bagging external event " + externalEvent + " with index " + eventIndex + " from " + sender().path.name)
      sender() ! ModelSimulator.buildBagEventDone(t, eventIndex)

    case bed: BagEventDone =>
      val t: Duration = Duration.parse(bed.getTimeString)
      val eventIndex = bed.getEventIndex
      awaitingBagEvents = awaitingBagEvents.filterNot(a => a.actor == sender()  && a.eventIndex == eventIndex)
      logDebug(t + " Received BagEventDone with index " + eventIndex + " from " + sender().path.name)
      checkDonePassingMessages(t)

    case m: Any=>
      throw new SynchronizationException(self.path + "Received message from " + sender + " in passingMessages state with no handler: [" + m.getClass + "] " + m)
  }

  /**
   * In this state, the ModelCoordinator is awaiting the completion of event transitions from all subordinate models.
   *
   * Upon receipt of a [[TransitionDone]] message, remove the sender from the [[synchronizeSet]] and record the next
   * state transition of the sender in the [[nextMap]].  If the [[synchronizeSet]] is empty, all subordinate models have
   * completed state transition.  Set the current time to [[TransitionDone]] time and send a [[TransitionDone]] message
   * to the parent coordinator with the [[currentTime]] and [[getNextTime]] as arguments.  Transition to the
   * [[processingOutput]] state.
   */
  def processingTransitions: Receive = {
    case td: StateTransitionDone =>
      val t: Duration = Duration.parse(td.getTimeString)
      val nextTime: Duration = Duration.parse(td.getNextTimeString)
      if (t.compareTo(currentTime) >= 0 && t.compareTo(nextTime) <= 0) {
        synchronizeSet = synchronizeSet.filterNot(_ == sender())
        logDebug(t + " " + sender.path.name +  " completed transition with its next scheduled transition at " + nextTime)
        nextMap.put(sender(), nextTime)
        if (synchronizeSet.isEmpty) {
          currentTime = t
          context.parent ! ModelSimulator.buildStateTransitionDone(currentTime, getNextTime)
          logDebug("Become: " + t + " All transitions complete.  Transitioning from processingTransitions to processingOutput")
          context.become(processingOutput)
        } else {
          logDebug(t + " Still have " + synchronizeSet.size + " subordinates executing transition.")
        }
      }
      else {
        throw new SynchronizationException(t + " in processing transitions, time in TransitionDone message " + t +
          " is not between current time: " + currentTime + " and next scheduled transition " + nextTime)
      }
    case m: Any=>
      throw new SynchronizationException("Received message in processingTransitions state with no handler: [" + m.getClass + "] " + m)
  }

}
